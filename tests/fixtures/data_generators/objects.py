from datetime import datetime, timezone, timedelta


def get_test_object(object_id, object_type = None, created_at = None, modified_at = None, \
    object_name = None, object_description = None, is_published = None, display_in_feed = None, feed_timestamp = None, \
    show_description = None, owner_id = None, \
    pop_keys = [], composite_subobject_object_type = None):
    """
    Returns a dictionary representing an object, which can be sent in a request body or inserted into the database.
    Accepts `object_id` and, optionally, other object attributes (except for `object_data`, which is generated by the function).
    If `owner_id` is omitted, it will not be returned in the response.

    Returnes dictionary contains `object_id`, `object_type`, `created_at`, `modified_at`, `object_name`, `object_description`,
    `is_published`, `display_in_feed`, `feed_timestamp`, `show_description`, `owner_id` and `object_data` attributes.
    Attributes, which are not required, can be removed by adding them into `pop_keys` list.

    `object_data` is generated accordingly to `object_type` provided or set based on `object_id`.
    If `composite_subobject_object_type` is set, composite object is returned with its first subobject containing object attributes & data of the specified type.
    """
    if object_type is None: object_type = "link"
    curr_time = datetime.now(tz=timezone.utc)

    obj = {
        "object_id": object_id,
        "object_type": object_type,
        "created_at": created_at if created_at is not None else curr_time,
        "modified_at": modified_at if modified_at is not None else curr_time,
        "object_name": object_name if object_name is not None else f"Object #{object_id}",
        "object_description": object_description if object_description is not None else f"Description to object {object_id}",
        "is_published": is_published if is_published is not None else False,
        "display_in_feed": display_in_feed if display_in_feed is not None else False,
        "feed_timestamp": feed_timestamp if feed_timestamp is not None else curr_time.isoformat(),
        "show_description": show_description if show_description is not None else False,
        "owner_id": owner_id,
        "object_data": get_test_object_data(object_id, object_type, composite_subobject_object_type)["object_data"]
    }

    for k in pop_keys:
        obj.pop(k, None)
    if owner_id is None: obj.pop("owner_id")

    return obj


def get_test_object_data(object_id, object_type = "link", composite_subobject_object_type = None):
    """
    Returns a dict with data to insert into and object data table (links, markdown, etc.)

    If `composite_subobject_object_type` is set, composite object is returned with its first subobject containing object attributes & data of the specified type.
    """
    if object_type == "link":
        object_data = {"link": f"https://test.link.{object_id}", "show_description_as_link": False}
    
    elif object_type == "markdown":
        object_data = {"raw_text": f"Raw markdown text #{object_id}"}
    
    elif object_type == "to_do_list":
        _item_states = ["active", "completed", "optional", "cancelled"]
        object_data = {
            "sort_type": "default",
            # item key order must match the order in which columns are declared in DB schemas,
            # because to-do lists tests depend on this order when comparing added/updated data
            "items": [{
                "item_number": x + 1,
                "item_state": _item_states[x % 4],
                "item_text": f"To-do list #{object_id}, item #{x+1}",
                "commentary": f"Commentary for to-do list #{object_id}, item #{x+1}",
                "indent": 0 if x % 4 < 2 else 1,
                "is_expanded": True
            } for x in range(max(object_id % 20, 1))]
        }

    elif object_type == "composite":
        so = {"object_id": 1, "row": 0, "column": 0, "selected_tab": 0, "is_expanded": True, 
              "show_description_composite": "inherit", "show_description_as_link_composite": "inherit"}
        
        if composite_subobject_object_type:
            so["object_name"] = "subobject name"
            so["object_description"] = "subobject description"
            so["is_published"] = False
            so["display_in_feed"] = False
            so["feed_timestamp"] = datetime.now(tz=timezone.utc).isoformat()
            so["show_description"] = False
            so["object_type"] = composite_subobject_object_type
            so["object_data"] = get_composite_subobject_object_data(1, object_type=composite_subobject_object_type)

        object_data = { "subobjects": [so], "deleted_subobjects": [], "display_mode": "basic", "numerate_chapters": False }
    
    else: raise ValueError(f"Received an incorrect object_type in `get_test_object_data` function: {object_type}")

    return {"object_id": object_id, "object_data": object_data}


def get_objects_attributes_list(min_id, max_id, owner_id = 1):
    """
    Returns a list object attributes for each object_id between `min_id` and `max_id` including.
    If `owner_id` is passed, it will be used as `owner_id` of each object (default value is 1).
    id <= 10 => link
    id <= 20 => markdown
    id <= 30 => to-do list
    id <= 40 => composite
    """

    def get_object_type(x):
        if 1 <= x <= 10: return "link"
        if 11 <= x <= 20: return "markdown"
        if 21 <= x <= 30: return "to_do_list"
        if 31 <= x <= 40: return "composite"
        raise ValueError(f"Received unexpected object ID {x} during object type generation.")
    
    def get_object_timestamp(x):
        """
        IDs dividable by 4 are created/modified earlier than IDs which are not.
        IDs dividable by 4 are sorted in descending order by timestamp; IDs not dividable by 4 are sorted in ascending order.
        E.g.: 
        ... 16 12 8 4 1 2 3 5 6 7 9 ...
        """
        delta = -x if x % 4 == 0 else x
        return datetime.now(tz=timezone.utc) + timedelta(minutes=delta)

    def get_object_feed_timestamp(x):
        """
        Returns string feed timestamp based on the provided object ID `x`.
        If x % 4 == 0, returns empty string.
        If x % 4 == 1, returns current time + 10 * x days.
        If x % 4 == 2, returns empty string.
        If x % 4 == 1, returns current time - 10 * x days.
        """
        if x % 2 == 0: return ""
        delta = 10 * x * (1 if x % 4 == 1 else -1)
        return (datetime.now(tz=timezone.utc) + timedelta(days=delta)).isoformat()

    return [{
        "object_id": x,
        "object_type": f"{get_object_type(x)}",
        "created_at": get_object_timestamp(x),
        "modified_at": get_object_timestamp(x),
        "object_name": chr(ord("a") + x - 1) + str((x+1) % 2),
        "object_description": chr(ord("a") + x - 1) + str((x+1) % 2) + " description",
        "is_published": False,
        "display_in_feed": False,
        "feed_timestamp": get_object_feed_timestamp(x),
        "show_description": False,
        "owner_id": owner_id
    } for x in range(min_id, max_id + 1)]


def add_composite_subobject(composite, object_id, row = None, column = None, selected_tab = 0, is_expanded = True, \
    show_description_composite = "inherit", show_description_as_link_composite = "inherit", \
    object_name = None, object_description = None, object_type = None, is_published = None, 
    display_in_feed = None, feed_timestamp = None, show_description = None, owner_id = None, \
    object_data = None):
    """
    Accepts a `composite` (dict respesenting `object_data` property of a composite object)
    and inserts a new subobject with provided or default props and data updates (if specified).
    """
    # Check if subobject attributes/data are correctly provided
    locals_ = locals()
    subobject_object_attributes = ("object_name", "object_description", "object_type", "is_published", "display_in_feed", "feed_timestamp", 
        "show_description", "owner_id", "object_data")
    subobject_object_attribute_values = {attr: locals_.get(attr) for attr in subobject_object_attributes}
    required_subobject_object_attribute_values = {attr: locals_.get(attr) for attr in ("object_name", "object_type")}
    optional_subobject_object_attributes = ("owner_id",)

    for attr in subobject_object_attributes:
        if subobject_object_attribute_values[attr] is not None:
            if None in required_subobject_object_attribute_values:
                raise Exception("Received incorrect subobject attributes or data when adding a new subobject.")
            break
    
    # Set default column value (last existing column)
    if column is None:
        column = 0
        for so in composite["object_data"]["subobjects"]:
            if so["column"] > column:
                column = so["column"]
    
    # Set default row value (new row)
    if row is None:
        row = 0
        for so in composite["object_data"]["subobjects"]:
            if so["row"] >= row and so["column"] == column:
                row = so["row"] + 1

    # Add new subobject
    new_so = {"object_id": object_id, "row": row, "column": column, "selected_tab": selected_tab, "is_expanded": is_expanded,
                "show_description_composite": show_description_composite, "show_description_as_link_composite": show_description_as_link_composite}
    if object_name != None:
        default_values = get_test_object(object_id, object_type=object_type, object_name=object_name)
        for attr in subobject_object_attributes:
            if attr in optional_subobject_object_attributes:
                if subobject_object_attribute_values[attr] is not None:
                    new_so[attr] = subobject_object_attribute_values[attr]
            else:
                new_so[attr] = subobject_object_attribute_values[attr] if subobject_object_attribute_values[attr] is not None else default_values[attr]

    composite["object_data"]["subobjects"].append(new_so)


def add_composite_deleted_subobject(composite, object_id, is_full_delete = True):
    """
    Accepts a `composite` (dict respesenting `object_data` property of a composite object)
    and inserts a new deleted subobject.
    """
    composite["object_data"]["deleted_subobjects"].append({"object_id": object_id, "is_full_delete": is_full_delete})


def get_composite_subobject_object_data(object_id, object_type = "link"):
    """
    Returns a dict with object data to be used as composite subobject data.
    """
    return get_test_object_data(object_id, object_type=object_type)["object_data"]
