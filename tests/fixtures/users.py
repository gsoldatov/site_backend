from datetime import datetime, timezone

from psycopg2.extensions import AsIs


def get_test_user(user_id, registered_at = None, login = None, password = None, password_repeat = None, username = None,
    user_level = None, can_login = None, can_edit_objects = None, pop_keys = []):
    """
    Returns a new dictionary for `users` table and auth route tests with attributes specified in `pop_keys` popped from it.
    `user_id` value is provided as the first argument, other user attributes can be optionally provided to override default values.
    """
    registered_at = registered_at if registered_at is not None else datetime.now(tz=timezone.utc)
    login = login if login is not None else f"login {user_id}"
    password = password if password is not None else f"password {user_id}"
    password_repeat = password_repeat if password_repeat is not None else password
    username = username if username is not None else f"username {user_id}"
    user_level = user_level if user_level is not None else "user"
    can_login = can_login if can_login is not None else True
    can_edit_objects = can_edit_objects if can_edit_objects is not None else True
    
    user = {"user_id": user_id, "registered_at": registered_at, "login": login, "password": password, "password_repeat": password_repeat,
        "username": username, "user_level": user_level, "can_login": can_login, "can_edit_objects": can_edit_objects}
    for k in pop_keys:
        user.pop(k, None)
    return user


def get_update_user_request_body(user = None, token_owner_password = None):
    """
    Returns a valid request body for /update/users route.
    `user` and `token_owner_password` are respective JSON attributes of the request body.
    """
    if token_owner_password is None: raise TypeError("`token_owner_password` is required.")

    if user is None:
        user = get_test_user(1, pop_keys=["registered_at"])
    
    return {"user": user, "token_owner_password": token_owner_password}


# Incorrect user registration data
incorrect_user_attributes = {
    "login": [1, False, "", "a"*256],
    "password": [1, False, "a"*7, "a"*73],
    "password_repeat": [1, False, "a"*7, "a"*73],
    "username": [1, False, "", "a"*256],
    "user_level": [1, False, "wrong str"],
    "can_login": [1, "str"],
    "can_edit_objects": [1, "str"]
}


def insert_users(users, db_cursor, generate_ids = False):
    """
    Inserts a list of `users` into users table.
    If `generate_ids` is true, values for user IDs will be generated by the database.
    """
    # query
    field_order = ["user_id", "registered_at", "login", "password", "username", "user_level", "can_login", "can_edit_objects"]
    if generate_ids: field_order = field_order[1:]
    fields_tuple = "(" + ", ".join(field_order) + ")"
    values = "(%s, %s, crypt(%s, gen_salt('bf')), %s, %s, %s, %s)" if generate_ids \
        else "(%s, %s, %s, crypt(%s, gen_salt('bf')), %s, %s, %s, %s)"
    query = f"INSERT INTO %s {fields_tuple} VALUES " + ", ".join((values for _ in range(len(users))))
    
    # params
    table = "users"
    params = [AsIs(table)]
    for u in users:
        for f in field_order:
            params.append(u[f])

    db_cursor.execute(query, params)


def clear_users(db_cursor):
    """
    Truncates `users` and, consequently, `sessions` table
    """
    db_cursor.execute("TRUNCATE TABLE users RESTART IDENTITY CASCADE")
