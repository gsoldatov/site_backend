from datetime import datetime, timezone, timedelta

from psycopg2.extensions import AsIs


__all__ = ["get_test_tag", "incorrect_tag_values", "tag_list", "insert_tags", "delete_tags"]

def get_test_tag(tag_id, tag_name = None, tag_description = None, is_published = None, created_at = None, modified_at = None, pop_keys = []):
    """
    Returns a new dictionary for tags table with attributes specified in pop_keys popped from it.
    If name is not provided, uses one of the default values (which are bound to specific IDs).
    """
    tag_name = tag_name if tag_name is not None else _tag_names.get(tag_id, f"tag name {tag_id}")
    tag_description = tag_description if tag_description is not None else f"Everything Related to {tag_name}"
    is_published = is_published if is_published is not None else True

    curr_time = datetime.now(tz=timezone.utc)
    created_at = created_at if created_at is not None else curr_time
    modified_at = modified_at if modified_at is not None else curr_time

    tag = {"tag_id": tag_id, "created_at": created_at, "modified_at": modified_at, "tag_name": tag_name, "tag_description": tag_description, "is_published": is_published}
    for k in pop_keys:
        tag.pop(k, None)
    return tag

_tag_names = {1: "Music", 2: "Movies", 3: "Books"}

incorrect_tag_values = [
    ("tag_id", -1), ("tag_id", "abc"), 
    ("tag_name", 123), ("tag_name", ""), ("tag_name", "a"*256),
    ("tag_description", 1),
    ("is_published", 1), ("is_published", "abc")
]

tag_list = [{
        "tag_id": x + 1,
        "created_at": datetime.now(tz=timezone.utc) + timedelta(minutes = x - 10 if x in (0, 4, 8) else x), # vowels first, consonants second
        "modified_at": datetime.now(tz=timezone.utc) + timedelta(minutes = x - 10 if x in (0, 4, 8) else x), # vowels first, consonants second
        "tag_name": chr(ord("a") + x) + str(x % 2),
        "tag_description": chr(ord("a") + x) + str(x % 2) + " description",
        "is_published": x % 2 == 0
    } for x in range(10)
]

def insert_tags(tags, db_cursor, generate_ids = False):
    """
    Inserts a list of tags into tags table.
    If `generate_ids` is true, values for tag IDs will be generated by the database.
    """
    # query
    field_order = ["tag_id", "created_at", "modified_at", "tag_name", "tag_description", "is_published"]
    if generate_ids: field_order = field_order[1:]
    fields_tuple = "(" + ", ".join(field_order) + ")"
    values = "(%s, %s, %s, %s, %s)" if generate_ids else "(%s, %s, %s, %s, %s, %s)"
    query = f"INSERT INTO %s {fields_tuple} VALUES " + ", ".join((values for _ in range(len(tags))))
    
    # params
    table = "tags"
    params = [AsIs(table)]
    for u in tags:
        for f in field_order:
            params.append(u[f])

    db_cursor.execute(query, params)


def delete_tags(tag_ids, db_cursor):
    """
    Deletes tags with provided IDs (this should also result in a cascade delete of related data from other tables).
    """
    table = "tags"
    query = "DELETE FROM %s WHERE tag_id IN (" + ", ".join(("%s" for _ in range(len(tag_ids)))) + ")"
    params = [AsIs(table)]
    params.extend(tag_ids)
    db_cursor.execute(query, params)
