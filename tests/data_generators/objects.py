from datetime import datetime, timezone, timedelta
from typing import Literal, Any

from backend_main.types.domains.objects.attributes import ObjectType


def get_test_object(
        object_id: int,
        object_type: ObjectType = "link",
        created_at: datetime | None = None,
        modified_at: datetime | None = None,
        object_name: str | None = None,
        object_description: str | None = None,
        is_published: bool | None = None,
        display_in_feed: bool | None = None,
        feed_timestamp: datetime | None = None,
        show_description: bool | None = None,
        owner_id: int | None = None,
        object_data: dict[str, Any] | None = None,
        pop_keys: list[str] = [],
        composite_subobject_object_type: ObjectType | None = None
    ):
    """
    Returns a dictionary representing an object, which can be sent in a request body or inserted into the database.
    Accepts `object_id` and, optionally, other object attributes (except for `object_data`, which is generated by the function).
    If `owner_id` is omitted, it will not be returned in the response.

    Returnes dictionary contains `object_id`, `object_type`, `created_at`, `modified_at`, `object_name`, `object_description`,
    `is_published`, `display_in_feed`, `feed_timestamp`, `show_description`, `owner_id` and `object_data` attributes.
    Attributes, which are not required, can be removed by adding them into `pop_keys` list.

    `object_data` is generated accordingly to `object_type` provided or set based on `object_id`.
    If `composite_subobject_object_type` is set, composite object is returned with its first subobject containing object attributes & data of the specified type.
    """
    if object_type is None: object_type = "link"
    curr_time = datetime.now(tz=timezone.utc)

    obj = {
        "object_id": object_id,
        "object_type": object_type,
        "created_at": created_at if created_at is not None else curr_time,
        "modified_at": modified_at if modified_at is not None else curr_time,
        "object_name": object_name if object_name is not None else f"Object #{object_id}",
        "object_description": object_description if object_description is not None else f"Description to object {object_id}",
        "is_published": is_published if is_published is not None else False,
        "display_in_feed": display_in_feed if display_in_feed is not None else False,
        "feed_timestamp": feed_timestamp,
        "show_description": show_description if show_description is not None else False,
        "owner_id": owner_id,
        "object_data": object_data if object_data is not None else \
            get_test_object_data(object_id, object_type, composite_subobject_object_type)["object_data"]
    }

    # Convert datetimes to ISO format
    for attr in ("created_at", "modified_at", "feed_timestamp"):
        if isinstance(obj[attr], datetime):
            obj[attr] = obj[attr].isoformat()

    for k in pop_keys:
        obj.pop(k, None)
    if owner_id is None: obj.pop("owner_id")

    return obj


def get_test_object_data(object_id, object_type = "link", composite_subobject_object_type = None):
    """
    Returns a dict with data to insert into and object data table (links, markdown, etc.)

    If `composite_subobject_object_type` is set, composite object is returned with its first subobject containing object attributes & data of the specified type.
    """
    if object_type == "link":
        object_data = get_link_data(link=f"https://test.link.{object_id}.com/", show_description_as_link=False)
    
    elif object_type == "markdown":
        object_data = get_markdown_data(raw_text=f"Raw markdown text #{object_id}")
    
    elif object_type == "to_do_list":
        _item_states = ["active", "completed", "optional", "cancelled"]
        object_data = get_to_do_list_data(
            sort_type="default",
            # item key order must match the order in which columns are declared in DB schemas,
            # because to-do lists tests depend on this order when comparing added/updated data
            items=[
                get_to_do_list_item_data(
                    item_number=x + 1,
                    item_state=_item_states[x % 4],
                    item_text=f"To-do list #{object_id}, item #{x+1}",
                    commentary=f"Commentary for to-do list #{object_id}, item #{x+1}",
                    indent=0 if x % 4 < 2 else 1,
                    is_expanded=True
            ) for x in range(max(object_id % 20, 1))]
        )

    elif object_type == "composite":
        so = {"subobject_id": 1, "row": 0, "column": 0, "selected_tab": 0, "is_expanded": True, 
              "show_description_composite": "inherit", "show_description_as_link_composite": "inherit"}
        
        if composite_subobject_object_type:
            so["object_name"] = "subobject name"
            so["object_description"] = "subobject description"
            so["is_published"] = False
            so["display_in_feed"] = False
            so["feed_timestamp"] = datetime.now(tz=timezone.utc).isoformat()
            so["show_description"] = False
            so["object_type"] = composite_subobject_object_type
            so["object_data"] = get_test_object_data(1, object_type=composite_subobject_object_type)["object_data"]

        object_data = { "subobjects": [so], "deleted_subobjects": [], "display_mode": "basic", "numerate_chapters": False }
    
    else: raise ValueError(f"Received an incorrect object_type in `get_test_object_data` function: {object_type}")

    return {"object_id": object_id, "object_data": object_data}


def get_link_data(
        link: str = "http://test.link.com",
        show_description_as_link: bool = False
    ):
    """ Generates a dict with default of custom values, which represents link object's data. """
    return {"link": link, "show_description_as_link": show_description_as_link}


def get_markdown_data(raw_text: str = "Raw markdown text"):
    """ Generates a dict with default of custom values, which represents markdown object's data. """
    return {"raw_text": raw_text}


def get_to_do_list_data(
        sort_type: Literal["default", "state"] = "default",
        items: list = []
    ):
    """ Generates a dict with default of custom values, which represents to-do list's object's data. """
    return {"sort_type": sort_type, "items": items}


def get_to_do_list_item_data(
        item_number: int = 0,
        item_state: Literal["active", "completed", "optional", "cancelled"] = "active",
        item_text: str | None = None,
        commentary: str | None = None,
        indent: int = 0,
        is_expanded: bool = True
    ):
    """ Generates a dict with default of custom values, which represents a single to-do list item. """
    return {
        "item_number": item_number,
        "item_state": item_state,
        "item_text": item_text if item_text is not None else f"item {item_number} text",
        "commentary": commentary if commentary is not None else f"item {item_number} commentary",
        "indent": indent,
        "is_expanded": is_expanded
    }


def get_composite_data(
        subobjects: list = [],
        deleted_subobjects: list = [],
        display_mode: Literal["basic", "grouped_links", "multicolumn", "chapters"] = "basic",
        numerate_chapters: bool = False
    ):
    """ Generates a dict with default of custom values, which represents composite object's data. """
    return {"subobjects": subobjects, "deleted_subobjects": deleted_subobjects,
            "display_mode": display_mode, "numerate_chapters": numerate_chapters}


def get_composite_subobject_data(
        subobject_id: int,
        column: int,
        row: int,
        selected_tab: int = 0,
        is_expanded: bool = True,
        show_description_composite: Literal["yes", "no", "inherit"] = "inherit",
        show_description_as_link_composite: Literal["yes", "no", "inherit"] = "inherit",
        
        object_type: ObjectType | None = None,
        object_name: str | None = None,
        object_description: str | None = None,
        is_published: bool | None = None,
        display_in_feed: bool | None = None,
        feed_timestamp: datetime | None = None,
        show_description: bool | None = None,
        owner_id: int | None = None,
        object_data: dict[str, Any] | None = None
    ):
    """
    Generates a dict with default of custom values, which represents a single composite subobject.
    If any object attribute value (`object_type`, `object_name`, etc.) is not None,
    adds default or provided object attributes to the result (for /objects/add & /objects/update tests).
    """
    # Add subobject attributes
    result = {
        "subobject_id": subobject_id,
        "row": row,
        "column": column,
        "selected_tab": selected_tab,
        "is_expanded": is_expanded,
        "show_description_composite": show_description_composite,
        "show_description_as_link_composite": show_description_as_link_composite
    }

    # Add object attributes, if any attribute is provided
    object_attribute_map = {
        "object_type": object_type,
        "object_name": object_name,
        "object_description": object_description,
        "is_published": is_published,
        "display_in_feed": display_in_feed,
        "feed_timestamp": feed_timestamp,
        "show_description": show_description,
        "owner_id": owner_id,
        "object_data": object_data
    }
    
    if list(filter(lambda x: x is not None, object_attribute_map.values())):
        object_attributes = get_test_object(subobject_id, **object_attribute_map)

        for attr in object_attribute_map:
            if attr in object_attributes:   # owner_id may be absent
                result[attr] = object_attributes[attr]
    
    # Convert datetimes to ISO format
    for attr in ("created_at", "modified_at", "feed_timestamp"):
        if attr in result and isinstance(result[attr], datetime):
            result[attr] = result[attr].isoformat()

    return result


def get_deleted_subobject(object_id: int, is_full_delete: bool = True):
    """
    Returns a dict, which indicates, that composite subobject is deleted
    """
    return {"object_id": object_id, "is_full_delete": is_full_delete}


def get_objects_attributes_list(min_id, max_id, owner_id = 1):
    """
    Returns a list object attributes for each object_id between `min_id` and `max_id` including.
    If `owner_id` is passed, it will be used as `owner_id` of each object (default value is 1).
    id <= 10 => link
    id <= 20 => markdown
    id <= 30 => to-do list
    id <= 40 => composite
    """

    def get_object_type(x):
        if 1 <= x <= 10: return "link"
        if 11 <= x <= 20: return "markdown"
        if 21 <= x <= 30: return "to_do_list"
        if 31 <= x <= 40: return "composite"
        raise ValueError(f"Received unexpected object ID {x} during object type generation.")
    
    def get_object_timestamp(x):
        """
        IDs dividable by 4 are created/modified earlier than IDs which are not.
        IDs dividable by 4 are sorted in descending order by timestamp; IDs not dividable by 4 are sorted in ascending order.
        E.g.: 
        ... 16 12 8 4 1 2 3 5 6 7 9 ...
        """
        delta = -x if x % 4 == 0 else x
        return datetime.now(tz=timezone.utc) + timedelta(minutes=delta)

    def get_object_feed_timestamp(x):
        """
        Returns string feed timestamp based on the provided object ID `x`.
        If x % 4 == 0, returns empty string.
        If x % 4 == 1, returns current time + 10 * x days.
        If x % 4 == 2, returns empty string.
        If x % 4 == 1, returns current time - 10 * x days.
        """
        if x % 2 == 0: return None
        delta = 10 * x * (1 if x % 4 == 1 else -1)
        return (datetime.now(tz=timezone.utc) + timedelta(days=delta)).isoformat()

    return [{
        "object_id": x,
        "object_type": f"{get_object_type(x)}",
        "created_at": get_object_timestamp(x),
        "modified_at": get_object_timestamp(x),
        "object_name": chr(ord("a") + x - 1) + str((x+1) % 2),
        "object_description": chr(ord("a") + x - 1) + str((x+1) % 2) + " description",
        "is_published": False,
        "display_in_feed": False,
        "feed_timestamp": get_object_feed_timestamp(x),
        "show_description": False,
        "owner_id": owner_id
    } for x in range(min_id, max_id + 1)]
